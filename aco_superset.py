# -*- coding: utf-8 -*-
"""ACO Superset

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RsMJbAJ8xNJ96H4RW1vvDFkMlWZz5i9a
"""


pip install folium

import geopandas as gpd
from shapely.wkt import loads
import matplotlib.pyplot as plt
import math
from shapely.geometry import LineString
from shapely.geometry import Point
from pyproj import Transformer
import networkx as nx
import random
import numpy as np
from math import radians, cos, sin, asin, sqrt
import folium

# Tu código para euclidean, Edge, wkt_to_edge y visualize_edges_on_plot viene aquí...
gdf = gpd.read_file('ruta_2_cut.shp')
def euclidean(node1, node2):
    lat1, lon1 = map(radians, node1)
    lat2, lon2 = map(radians, node2)

    # Fórmula de Haversine
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a))
    r = 6371  # Radio de la Tierra en kilómetros. Usar 3956 para millas
    return c * r * 1000  # Retorna la distancia en metros

# Modificamos la clase Edge para almacenar todos los puntos de la LineString
class Edge:
    def __init__(self, coordinates, cost):
        self.coordinates = coordinates  # Ahora almacenamos todos los puntos de la LineString
        self.cost = cost

# Modificamos la función wkt_to_edge para manejar todas las coordenadas de la LineString
def wkt_to_edge(geom_wkt):
    geometry = loads(geom_wkt)
    coordinates = list(geometry.coords)
    # Calculamos el costo sumando las distancias euclidianas entre cada par de puntos consecutivos
    cost = sum(euclidean(coordinates[i], coordinates[i+1]) for i in range(len(coordinates)-1))
    return Edge(coordinates, cost)


fig, ax = plt.subplots(figsize=(10, 10))

# Graficar el GeoDataFrame
gdf.plot(ax=ax, linewidth=1, edgecolor='black')

# Mostrar todos los puntos de las geometrías y anotar las coordenadas
for idx, row in gdf.iterrows():
    # Si la geometría es una LineString, graficar cada punto y anotar las coordenadas
    if isinstance(row['geometry'], LineString):
        x, y = row['geometry'].xy
        ax.plot(x, y, 'o', markersize=5, color='red')
        for (point_x, point_y) in zip(x, y):
            ax.text(point_x, point_y, f'({point_x:.3f}, {point_y:.3f})', fontsize=9, verticalalignment='bottom')





def visualize_edges_on_plot(edges, x_range, y_range):
    plt.figure(figsize=(5, 5))

    for edge in edges:
        x_coords, y_coords = zip(*edge.coordinates)
        plt.plot(x_coords, y_coords, 'b-', linewidth=2)

    plt.xlabel('Longitud')
    plt.ylabel('Latitud')
    plt.title('Visualización de Bordes en un Gráfico')
    plt.xlim(x_range[0], x_range[1])  # Ajustar estos valores al mínimo y máximo de X
    plt.ylim(y_range[0], y_range[1])  # Ajustar estos valores al mínimo y máximo de Y
    plt.show()

# Resto del código permanece igual...

# Ahora, en lugar de imprimir las geometrías y agregarlas a una lista como strings,
# vamos a trabajar directamente con las geometrías de tipo LineString.

# Calcula los rangos de coordenadas basados en los valores mínimos y máximos

x_min, y_min, x_max, y_max = gdf.total_bounds
x_range = (x_min, x_max)
y_range = (y_min, y_max)

edges = []

for idx, row in gdf.iterrows():
    # Asegúrate de que la geometría es una LineString
    if isinstance(row['geometry'], LineString):
        # Convierte la geometría LineString en un objeto Edge y añádela a la lista
        edges.append(wkt_to_edge(row['geometry'].wkt))

# Visualiza los bordes en un solo gráfico
visualize_edges_on_plot(edges, x_range, y_range)

x_min, y_min, x_max, y_max = gdf.total_bounds
x_range = (x_min, x_max)
y_range = (y_min, y_max)

edges = []

for idx, row in gdf.iterrows():
    # Asegúrate de que la geometría es una LineString
    if isinstance(row['geometry'], LineString):
        # Convierte la geometría LineString en un objeto Edge y añádela a la lista
        edges.append(wkt_to_edge(row['geometry'].wkt))

# Visualiza los bordes en un solo gráfico




G = nx.Graph()
for edge in edges:
    # Suponiendo que cada objeto 'edge' tiene una lista de 'coordinates' donde cada par es un nodo
    for i in range(len(edge.coordinates) - 1):
        node_start = edge.coordinates[i]
        node_end = edge.coordinates[i + 1]
        # Agrega los nodos y la arista entre ellos
        G.add_node(node_start)
        G.add_node(node_end)
        # Agrega una arista con el costo como atributo 'weight'
        distance = euclidean(node_start, node_end)
        G.add_edge(node_start, node_end, weight=distance)

pos = {node: (node[0], node[1]) for node in G.nodes()}
# Dibujar el grafo
plt.figure(figsize=(12, 8))
nx.draw_networkx_nodes(G, pos, node_size=50, node_color='blue')
nx.draw_networkx_edges(G, pos, width=1)

# Etiquetas de las aristas con los pesos (distancias)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=5)

plt.title("Grafo con Pesos de las Aristas")
plt.xlabel("Longitud")
plt.ylabel("Latitud")
plt.show()


nodes = G.nodes()
#print("nodes", nodes)
edge_labels = {}
for i, edge in enumerate(G.edges()):
    edge_labels[edge] = i + 1

edges = G.edges()
#print("egdes", edges)

for edge in edges:
    G.add_node(edge[0])
    G.add_node(edge[1])
pos = {node: (node[0], node[1]) for node in G.nodes()}
nx.draw_networkx_edges(G, pos, alpha=0.5, width=1)
nx.draw_networkx_edges(G, pos, alpha=0.5, width=1, arrows=True)
for i, edge in enumerate(G.edges()):
    start, end = edge
    x_mid = (start[0] + end[0]) / 2
    y_mid = (start[1] + end[1]) / 2
    plt.text(x_mid, y_mid, str(i + 1), ha="center", va="center", fontsize=10, color="red")
for node in G.nodes:
    G.nodes[node]['pos'] = node

def draw_final_pheromones(self, best_solution):
    plt.figure(figsize=(12, 8))
    pos = nx.get_node_attributes(self.G, 'pos')
    nx.draw(self.G, pos, node_color='lightblue', edge_color='gray')

    for edge in self.G.edges():
        pheromone_level = self.G[edge[0]][edge[1]]['pheromone']
        linewidth = max(pheromone_level * 5, 0.1)  # Asegúrate de que siempre hay una línea visible
        nx.draw_networkx_edges(self.G, pos, edgelist=[edge], width=linewidth, alpha=0.7, edge_color='black')

    # Dibujar el mejor camino encontrado
    path_edges = list(zip(best_solution, best_solution[1:]))
    nx.draw_networkx_edges(self.G, pos, edgelist=path_edges, edge_color='red', width=2)
    nx.draw_networkx_nodes(self.G, pos, nodelist=best_solution, node_color='red', node_size=50)

    plt.title("Estado Final de las Feromonas en el Grafo")
    plt.show()


def draw_final_pheromones_with_folium(self, best_solution):
    # Inicializar un mapa de Folium en el punto central de tus nodos
    average_lat = sum(node[1] for node in self.G.nodes()) / len(self.G.nodes())
    average_lon = sum(node[0] for node in self.G.nodes()) / len(self.G.nodes())
    folium_map = folium.Map(location=[average_lat, average_lon], zoom_start=14)

    # Dibujar todos los nodos y bordes con un color base
    for node in self.G.nodes():
        folium.CircleMarker(
            location=[node[1], node[0]],
            radius=3,
            color='lightblue',
            fill=True,
            fill_color='lightblue'
        ).add_to(folium_map)

    for edge in self.G.edges():
        location1 = [self.G.nodes[edge[0]]['pos'][1], self.G.nodes[edge[0]]['pos'][0]]
        location2 = [self.G.nodes[edge[1]]['pos'][1], self.G.nodes[edge[1]]['pos'][0]]
        folium.PolyLine([location1, location2], color='gray', weight=1).add_to(folium_map)

    # Dibujar los bordes con el nivel de feromona
    for edge in self.G.edges():
        pheromone_level = self.G[edge[0]][edge[1]]['pheromone']
        linewidth = max(pheromone_level * 5, 0.1)
        location1 = [self.G.nodes[edge[0]]['pos'][1], self.G.nodes[edge[0]]['pos'][0]]
        location2 = [self.G.nodes[edge[1]]['pos'][1], self.G.nodes[edge[1]]['pos'][0]]
        folium.PolyLine([location1, location2], color='black', weight=linewidth).add_to(folium_map)

    # Dibujar el mejor camino encontrado con un color distinto
    for i in range(len(best_solution) - 1):
        location1 = [self.G.nodes[best_solution[i]]['pos'][1], self.G.nodes[best_solution[i]]['pos'][0]]
        location2 = [self.G.nodes[best_solution[i+1]]['pos'][1], self.G.nodes[best_solution[i+1]]['pos'][0]]
        folium.PolyLine([location1, location2], color='red', weight=2).add_to(folium_map)

    # Mostrar el mapa en el Jupyter Notebook
    return folium_map


def plot_path(path, G):
    pos = {node: (node[0], node[1]) for node in G.nodes()}
    plt.figure(figsize=(12, 8))

    # Dibujar todos los nodos y aristas
    nx.draw_networkx_nodes(G, pos, node_size=50, node_color='blue')
    nx.draw_networkx_edges(G, pos, width=1, alpha=0.5)

    # Dibujar las etiquetas de las aristas (distancias)
    edge_labels = {(u, v): f"{d['weight']:.2f}" for u, v, d in G.edges(data=True)}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=8)

    # Extraer coordenadas del camino
    x = [pos[node][0] for node in path]
    y = [pos[node][1] for node in path]

    # Dibujar el camino
    plt.plot(x, y, color="red", linewidth=2)

    plt.xlabel("Longitud")
    plt.ylabel("Latitud")
    plt.title("Camino Encontrado por una Hormiga")
    plt.show()



class AntColonyOptimizer:
    def __init__(self, G, start, end, num_ants, iterations, alpha, beta, evaporation_rate, mandatory_nodes):
        self.G = G
        self.start = start
        self.end = end
        self.num_ants = num_ants
        self.iterations = iterations
        self.alpha = alpha
        self.beta = beta
        self.evaporation_rate = evaporation_rate
        self.pheromone = {edge: 1.0 for edge in G.edges()}  # Inicialización simple
        self.initialize_pheromones()
        self.mandatory_nodes = mandatory_nodes

    def initialize_pheromones(self):
        # Inicializar la matriz de feromonas
        for edge in self.G.edges():
            self.G[edge[0]][edge[1]]['pheromone'] = 1





    def draw_current_selection(self, current_node, next_node, visited):
      plt.figure(figsize=(8, 6))
      pos = nx.get_node_attributes(self.G, 'pos')
      nx.draw(self.G, pos, node_color='lightblue', edge_color='gray')

    # Dibujar los nodos visitados en un color diferente
      nx.draw_networkx_nodes(self.G, pos, nodelist=list(visited), node_color='green')

    # Dibujar el nodo actual y el siguiente en colores distintos
      nx.draw_networkx_nodes(self.G, pos, nodelist=[current_node], node_color='red')

      if(next_node is not None):
        nx.draw_networkx_nodes(self.G, pos, nodelist=[next_node], node_color='yellow')

    # Dibujar la arista seleccionad
      if(next_node is not None):
        pheromone_level = self.G[current_node][next_node]['pheromone']
        linewidth = pheromone_level * 5  # Ajusta este valor si es necesario
        nx.draw_networkx_edges(self.G, pos, edgelist=[(current_node, next_node)],
                               edge_color='blue', width=linewidth, style='dashed')


      for edge in self.G.edges():
        pheromone_level = self.G[edge[0]][edge[1]]['pheromone']
        nx.draw_networkx_edges(self.G, pos, edgelist=[edge], width=pheromone_level * 2, alpha=0.1, edge_color='black')
        x_values = [pos[edge[0]][0], pos[edge[1]][0]]
        y_values = [pos[edge[0]][1], pos[edge[1]][1]]
        plt.text(x=sum(x_values)/2, y=sum(y_values)/2, s=f'{pheromone_level:.2%}', fontsize=9)
      plt.title(f"Current Node: {current_node}, Next Node: {next_node}")
      plt.show()



    def calculate_transition_probabilities(self, current_node, neighbors, visited):
        pheromone = [self.G[current_node][neighbor]['pheromone'] for neighbor in neighbors]
        visibility = [1/self.G[current_node][neighbor]['weight'] for neighbor in neighbors]  # Assuming 'weight' is the distance

        pheromone = [pow(p, self.alpha) for p in pheromone]
        visibility = [pow(v, self.beta) for v in visibility]

        probabilities = [p * v for p, v in zip(pheromone, visibility)]
        sum_probabilities = sum(probabilities)
        probabilities = [p / sum_probabilities for p in probabilities]

        return probabilities

    def select_next_node(self, current_node, visited):
      next_node = None

    # Priorizar nodos obligatorios no visitados
      if self.mandatory_nodes:
        mandatory_neighbors = [node for node in self.mandatory_nodes if node in self.G.neighbors(current_node) and node not in visited]
        if mandatory_neighbors:
            next_node = self.select_from_mandatory_nodes(mandatory_neighbors, current_node, visited)

    # Si no hay nodos obligatorios no visitados, elige entre otros vecinos
      if next_node is None:
        other_neighbors = [neighbor for neighbor in self.G.neighbors(current_node) if neighbor not in visited]
        if other_neighbors:
            probabilities = self.calculate_transition_probabilities(current_node, other_neighbors, visited)
            next_node = random.choices(other_neighbors, weights=probabilities, k=1)[0]

    # Verificar si hay una arista válida hacia el siguiente nodo
      if next_node and not self.G.has_edge(current_node, next_node):
        return None

      return next_node


    def select_from_mandatory_nodes(self, mandatory_neighbors, current_node, visited):
    # Ejemplo de selección basada en la distancia más corta
      closest_node = min(mandatory_neighbors, key=lambda node: self.G[current_node][node]['weight'])
      return closest_node

    def construct_solution(self):
      path = [self.start]
      visited = set(path)
      current_node = self.start

      while current_node != self.end:

        next_node = self.select_next_node(current_node, visited)

        if next_node is None or not self.G.has_edge(current_node, next_node):
            index_pos = path.index(path[-1])
            backtrack_number = 1
            while next_node is None:
              current_node = path[index_pos - backtrack_number]
              #self.draw_current_selection(current_node, next_node, visited)
              # agregar el retroceso al path
              path.append(current_node)
              # print(path)
              # verificar el next_node . va ser none seguimos en el hilo
              next_node = self.select_next_node(current_node, visited)
              # print(next_node)
              # hay k retroceder uno mas
              backtrack_number += 1


        # self.draw_pheromone_levels(self.pheromone)
        path.append(next_node)
        visited.add(next_node)
        current_node = next_node

        # print("current_node" , current_node, " -----------  end", self.end)

        if current_node == self.end:
            break  # Si hemos llegado al final, salimos del bucle

      # print('acabo una solucion XD')
      return path

    def path_meets_requirements(self, path):
      return self.contains_required_nodes(path) and path[-1] == self.end

    def update_pheromones(self, paths):
    # Evaporación de feromonas en todas las aristas
      for edge in self.G.edges():
        self.G[edge[0]][edge[1]]['pheromone'] *= (1 - self.evaporation_rate)

    # Identificar la mejor ruta de esta iteración
      best_path = min(paths, key=self.calculate_path_length)
      best_path_length = self.calculate_path_length(best_path)
      best_path_contains_required_nodes = self.contains_required_nodes(best_path)

    # Reforzar solo la mejor ruta
      if best_path_contains_required_nodes:
        mandatory_factor = 2  # o el valor que se considere apropiado
      else:
        mandatory_factor = 1
      for i in range(len(best_path) - 1):
        self.G[best_path[i]][best_path[i+1]]['pheromone'] += mandatory_factor / best_path_length



    def draw_final_pheromones(self, best_solution):
      plt.figure(figsize=(12, 8))
      pos = nx.get_node_attributes(self.G, 'pos')
      nx.draw(self.G, pos, node_color='lightblue', edge_color='gray')

      for edge in self.G.edges():
        pheromone_level = self.G[edge[0]][edge[1]]['pheromone']
        linewidth = max(pheromone_level * 5, 0.1)  # Asegúrate de que siempre hay una línea visible
        nx.draw_networkx_edges(self.G, pos, edgelist=[edge], width=linewidth, alpha=0.7, edge_color='black')



    # Dibujar el mejor camino encontrado
      path_edges = list(zip(best_solution, best_solution[1:]))
      nx.draw_networkx_edges(self.G, pos, edgelist=path_edges, edge_color='red', width=2)
      nx.draw_networkx_nodes(self.G, pos, nodelist=best_solution, node_color='red', node_size=50)

      for edge in path_edges:
        # Calcular la posición del texto
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        x_text = (x0 + x1) / 2
        y_text = (y0 + y1) / 2

        # Obtener el nivel de feromona de la arista
        pheromone_level = self.G[edge[0]][edge[1]]['pheromone']
        # Colocar el texto en la posición calculada
        plt.text(x_text, y_text, f'{pheromone_level:.2%}', fontsize=9, ha='center', va='center', color='green')

      plt.title("Estado Final de las Feromonas en el grafo")
      plt.show()

    def draw_final_pheromones_with_folium(self, best_solution):
    # Inicializar un mapa de Folium en el punto central de tus nodos
      average_lat = sum(node[1] for node in self.G.nodes()) / len(self.G.nodes())
      average_lon = sum(node[0] for node in self.G.nodes()) / len(self.G.nodes())
      folium_map = folium.Map(location=[average_lat, average_lon], zoom_start=14)

    # Añadir el ícono del camión de basura en el nodo de inicio
      start_node = best_solution[0]
      folium.Marker(
        location=[start_node[1], start_node[0]],
        icon=folium.Icon(icon="trash", prefix="fa"),
        popup="Camión de Basura"
      ).add_to(folium_map)

    # Añadir marcadores para los nodos obligatorios
      for node in self.mandatory_nodes:
        folium.CircleMarker(
            location=[node[1], node[0]],
            radius=5,
            color='green',
            fill=True,
            fill_color='green',
            popup="Nodo Obligatorio"
        ).add_to(folium_map)

    # Dibujar todos los nodos y bordes con un color base
      for node in self.G.nodes():
        folium.CircleMarker(
            location=[self.G.nodes[node]['pos'][1], self.G.nodes[node]['pos'][0]],
            radius=3,
            color='lightblue',
            fill=True,
            fill_color='lightblue'
        ).add_to(folium_map)

    # Dibujar los bordes con el nivel de feromona
      for edge in self.G.edges():
        pheromone_level = self.G[edge[0]][edge[1]]['pheromone']
        linewidth = max(pheromone_level * 5, 0.1)
        location1 = [self.G.nodes[edge[0]]['pos'][1], self.G.nodes[edge[0]]['pos'][0]]
        location2 = [self.G.nodes[edge[1]]['pos'][1], self.G.nodes[edge[1]]['pos'][0]]
        folium.PolyLine([location1, location2], color='black', weight=linewidth).add_to(folium_map)

    # Dibujar el mejor camino encontrado con un color distinto
      for i in range(len(best_solution) - 1):
        location1 = [self.G.nodes[best_solution[i]]['pos'][1], self.G.nodes[best_solution[i]]['pos'][0]]
        location2 = [self.G.nodes[best_solution[i+1]]['pos'][1], self.G.nodes[best_solution[i+1]]['pos'][0]]
        folium.PolyLine([location1, location2], color='red', weight=2).add_to(folium_map)

    # Guardar el mapa en un archivo HTML
      folium_map.save('final_pheromone_levels_map.html')



    def contains_required_nodes(self, path):
      return all(required_node in path for required_node in self.mandatory_nodes)

    def calculate_path_length(self, path):
       length = 0
       for i in range(len(path) - 1):
        if not self.G.has_edge(path[i], path[i + 1]):
            raise ValueError("Edge does not exist")
        length += self.G[path[i]][path[i + 1]]['weight']
       return length


    def run(self):
      best_solution = None
      best_solution_length = float('inf')
      all_paths = []  # Lista para almacenar todos los caminos

      for iteration in range(self.iterations):
        paths = [self.construct_solution() for _ in range(self.num_ants)]
        self.update_pheromones(paths)



        for path in paths:
            if(path[-1] == self.end):
              path_length = self.calculate_path_length(path)
              if path_length < best_solution_length and self.contains_required_nodes(path):
                  best_solution = path
                  best_solution_length = path_length
                  all_paths.append(path)


        # pos = nx.get_node_attributes(self.G, 'pos')  # Asegúrate de tener las posiciones de los nodos
        # # plot_graph_with_pheromones(self.G, pos)
        # plot_graph_with_weights(G, pos)

      if best_solution is not None:
          self.draw_final_pheromones_with_folium(best_solution)  # Llamamos a la nueva función aquí
          return all_paths, best_solution, best_solution_length
      else:
          print("No se encontró ninguna ruta válida")

      # Imprime el nodo al que va a ir la hormiga siguiente
      #print("Nodo siguiente:", self.select_next_node(self.start, set()))


alpha = 1.0
beta = 1.0
evaporation_rate = 0.1
num_ants = 350
iterations = 1500
aco = AntColonyOptimizer(G, (-76.8742529, -12.0029755),(-76.8746775, -12.0030962), num_ants, iterations, alpha, beta, evaporation_rate, [(-76.8737651 , -12.0045382), (-76.8725329, -12.0029627),(-76.8736475, -12.0032834), (-76.8724898, -12.003905), (-76.8734215, -12.0040177), (-76.874108,-12.0034341 ), (-76.8724227, -12.0053163),(-76.872401, -12.0057888)])
all_paths, best_path, best_solution_length = aco.run()
print("Best path found:", best_path)
best_path_coordinates = best_path

for path in all_paths:
    plot_path(path, aco.G)

# Definir los nodos
nodos = best_path
# Convertir las coordenadas a un formato de Matplotlib
x = [nodo[0] for nodo in nodos]
y = [nodo[1] for nodo in nodos]

# Crear un plot
plt.plot(x, y, 'o')

def euclidean_distance(point1, point2):
    lat1, lon1 = point1
    lat2, lon2 = point2
    distance = math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)
    return distance

def calcular_distancia_total(coordenadas):
    distancia_total = 0
    for i in range(len(coordenadas) - 1):
        punto_actual = coordenadas[i]
        punto_siguiente = coordenadas[i + 1]
        distancia_total += euclidean_distance(punto_actual, punto_siguiente) * 111000  # Aproximación para convertir grados a metros
    return distancia_total

# Lista de coordenadas de los nodos
total_distance = calcular_distancia_total(best_path)
print("Distancia total en metros: ", total_distance)

#(-76.7043489, -11.9415553)
# (-76.7063431, -11.9447529)
# Mostrar el plot
plt.show()



